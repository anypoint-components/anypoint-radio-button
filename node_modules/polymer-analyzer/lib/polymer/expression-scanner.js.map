{"version":3,"sources":["polymer/expression-scanner.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;AAEH,qCAAqC;AACrC,4CAA4C;AAI5C,oDAAoD;AAEpD,uEAAwD;AACxD,0CAAkG;AAGlG,MAAM,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC;AAC1B,MAAM,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AAE5C,MAAM,qBAAqB,GAAG,CAAC,CAAC,GAAG,CAC/B,UAAU,EACV,CAAC,CAAC,EAAE,CACA,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,UAAU,CAAC,EAChC,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,EAC9B,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,YAAY,CAAC,EAClC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,CAChB,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,EACxB,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,EACtB,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,EAC1B,CAAC,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAI3C;;;;;;;;GAQG;AACH,oCAA2C,IAAoB;IAC7D,MAAM,CAAC,IAAI,CAAC,QAAQ,CACT,IAAI,EAAE,qBAAqB,EAAE,IAAI,CAAC,yBAAyB,CACxC,CAAC;AACjC,CAAC;AAJD,gEAIC;AAWD;IAiBE,YACI,WAAwB,EAAE,cAAsB,EAAE,GAAkB,EACpE,UAAgC,EAAE,QAAwB;QAjBrD,aAAQ,GAAc,EAAE,CAAC;QAOlC;;;;;WAKG;QACH,eAAU,GAAoD,EAAE,CAAC;QAK/D,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,cAAc,GAAG,GAAG,CAAC;QAC1B,IAAI,CAAC,cAAc,GAAG;YACpB,IAAI,EAAE,WAAW,CAAC,KAAK,CAAC,IAAI;YAC5B,GAAG,EAAE,WAAW,CAAC,KAAK,CAAC,MAAM;SAC9B,CAAC;QACF,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,6BAA6B,CAAC,UAAU,CAAC,CAAC;IACjD,CAAC;IAED;;OAEG;IACH,kBAAkB,CAAC,IAAgB;QACjC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC;QACT,CAAC;QACD,MAAM,8BAA8B,GAAG;YACrC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI;YAC3B,qEAAqE;YACrE,KAAK,EAAE,EAAC,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAC;YACvE,GAAG,EAAE,EAAC,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,EAAC;SAClE,CAAC;QACF,MAAM,CAAC,0BAAkB,CACrB,8BAA8B,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;IAC3D,CAAC;IAEO,6BAA6B,CAAC,UAAgC;QACpE,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,gCAAgC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EACjE,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC;QACT,CAAC;QACD,MAAM,mBAAmB,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QACzD,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,qBAAqB,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC;YACtD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,+BAA+B,mBAAmB,CAAC,IAAI,EAAE,EACzD,mBAAmB,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC;QACT,CAAC;QACD,IAAI,UAAU,GAAG,mBAAmB,CAAC,UAAU,CAAC;QAEhD,IAAI,CAAC,mBAAmB,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;QACjD,EAAE,CAAC,CAAC,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,QAAQ,KAAK,GAAG,CAAC,CAAC,CAAC;YACvE,UAAU,GAAG,UAAU,CAAC,QAAQ,CAAC;QACnC,CAAC;QACD,IAAI,CAAC,gCAAgC,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;IAC1D,CAAC;IAEO,mBAAmB,CACvB,UAA4B,EAAE,UAAgC;QAChE,MAAM,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACnB,KAAK,gBAAgB;gBACnB,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBACpC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,8CAA8C,EAAE,UAAU,CAAC,CAAC,CAAC;gBACnE,CAAC;gBACD,KAAK,CAAC;YACR,KAAK,gBAAgB;gBACnB,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBACxC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,gCAAgC,EAAE,UAAU,CAAC,CAAC,CAAC;gBACrD,CAAC;gBACD,KAAK,CAAC;YACR,KAAK,MAAM;gBACT,KAAK,CAAC,CAAE,mBAAmB;YAC7B;gBACE,MAAM,KAAK,GAAU,UAAU,CAAC;gBAChC,MAAM,IAAI,KAAK,CAAC,2BAA2B,KAAK,EAAE,CAAC,CAAC;QACxD,CAAC;IACH,CAAC;IAEO,gCAAgC,CACpC,UAAsB,EAAE,WAAoB;QAC9C,EAAE,CAAC,CAAC,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,IAAI,UAAU,CAAC,QAAQ,KAAK,GAAG,CAAC,CAAC,CAAC;YACvE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACjD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,gEAAgE,EAChE,UAAU,CAAC,CAAC,CAAC;gBACjB,MAAM,CAAC;YACT,CAAC;YACD,IAAI,CAAC,gCAAgC,CAAC,UAAU,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YAClE,MAAM,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAChC,MAAM,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACnC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;gBACnB,IAAI,EAAE,UAAU,CAAC,IAAI;gBACrB,WAAW,EAAE,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAE;aAClD,CAAC,CAAC;YACH,MAAM,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,KAAK,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACzC,IAAI,CAAC,gCAAgC,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YAChE,MAAM,CAAC;QACT,CAAC;QACD,EAAE,CAAC,CAAC,WAAW,IAAI,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACtD,IAAI,CAAC,gCAAgC,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;YAChE,GAAG,CAAC,CAAC,MAAM,GAAG,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC;gBACvC,IAAI,CAAC,gCAAgC,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YACpD,CAAC;YACD,MAAM,CAAC;QACT,CAAC;QACD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CACtC,sEAAsE;YAClE,GAAG,UAAU,CAAC,IAAI,qBAAqB,EAC3C,UAAU,CAAC,CAAC,CAAC;IACnB,CAAC;IAEO,kBAAkB,CAAC,OAAe,EAAE,IAAgB;QAC1D,MAAM,CAAC,IAAI,eAAO,CAAC;YACjB,IAAI,EAAE,4BAA4B;YAClC,OAAO;YACP,WAAW,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAE;YAC3C,QAAQ,EAAE,gBAAQ,CAAC,OAAO;YAC1B,cAAc,EAAE,IAAI,CAAC,SAAS;SAC/B,CAAC,CAAC;IACL,CAAC;CACF;AA9ID,sDA8IC;AAED,oCAA4C,SAAQ,qBAAqB;IAiCvE,YACI,OAAuB,EAAE,iBAA0B,EAAE,SAAkB,EACvE,SAA2B,EAAE,SAA8B,EAC3D,WAAwB,EAAE,cAAsB,EAAE,GAAkB,EACpE,QAA4B;QAC9B,KAAK,CAAC,WAAW,EAAE,cAAc,EAAE,GAAG,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;QAhCnD,oBAAe,GAAG,WAAW,CAAC;QAiCrC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;CACF;AA7CD,wEA6CC;AAED,mCAA2C,SAAQ,qBAAqB;IAWtE,YACI,SAAkB,EAAE,OAAuB,EAAE,WAAwB,EACrE,cAAsB,EAAE,GAAkB,EAC1C,QAA4B;QAC9B,KAAK,CAAC,WAAW,EAAE,cAAc,EAAE,GAAG,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;QANnD,oBAAe,GAAG,WAAW,CAAC;QAOrC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;CACF;AAnBD,sEAmBC;AAED,qCAA6C,SAAQ,qBAAqB;IAKxE,YACI,OAAmB,EAAE,WAAwB,EAAE,cAAsB,EACrE,GAAkB,EAAE,IAA0B,EAC9C,QAA4B;QAC9B,KAAK,CAAC,WAAW,EAAE,cAAc,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QANjD,oBAAe,GAAG,YAAY,CAAC;QAOtC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;CACF;AAZD,0EAYC;AAED;;GAEG;AACH,oCAA2C,QAA4B;IACrE,MAAM,CAAC,gCAAgC,CACnC,QAAQ,EAAE,0BAA0B,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;AAC1D,CAAC;AAHD,gEAGC;AAED,+CACI,QAA4B,EAAE,QAAkB;IAClD,MAAM,CAAC,gCAAgC,CACnC,QAAQ,EACR,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,0BAA0B,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5E,CAAC;AALD,sFAKC;AAED,0CACI,QAA4B,EAAE,SAA6B;IAC7D,MAAM,OAAO,GAAgC,EAAE,CAAC;IAChD,MAAM,QAAQ,GAAc,EAAE,CAAC;IAC/B,GAAG,CAAC,CAAC,MAAM,QAAQ,IAAI,SAAS,CAAC,CAAC,CAAC;QACjC,GAAG,CAAC,CAAC,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACrD,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBACxC,+BAA+B,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;YACrE,CAAC;YACD,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBACf,GAAG,CAAC,CAAC,MAAM,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;oBAC9B,2BAA2B,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;gBACvE,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,CAAC,EAAC,WAAW,EAAE,OAAO,EAAE,QAAQ,EAAC,CAAC;AAC1C,CAAC;AAED,yCACI,QAA4B,EAC5B,IAAoB,EACpB,OAAoC,EACpC,QAAmB;IACrB,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC;IAC9B,MAAM,YAAY,GAAG,uBAAuB,CAAC,IAAI,CAAC,CAAC;IACnD,EAAE,CAAC,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;QAC9B,MAAM,CAAC;IACT,CAAC;IACD,MAAM,eAAe,GAAG,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;IAC1D,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;QACrB,MAAM,CAAC;IACT,CAAC;IAED,MAAM,qBAAqB,GACvB,QAAQ,CAAC,sBAAsB,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;IAC3D,GAAG,CAAC,CAAC,MAAM,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC;QACvC,MAAM,WAAW,GAAG,QAAQ,CAAC,oBAAoB,CAC7C,WAAW,CAAC,UAAU,GAAG,qBAAqB,EAC9C,WAAW,CAAC,QAAQ,GAAG,qBAAqB,CAAC,CAAC;QAElD,MAAM,WAAW,GACb,eAAe,CAAC,WAAW,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;QAE7D,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACjB,QAAQ,CAAC;QACX,CAAC;QACD,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACnC,QAAQ,CAAC,IAAI,CACT,IAAI,eAAO,iBAAE,cAAc,EAAE,QAAQ,IAAK,WAAW,CAAC,UAAU,EAAE,CAAC,CAAC;QAC1E,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,UAAU,GAAG,IAAI,6BAA6B,CAChD,WAAW,CAAC,SAAS,EACrB,IAAI,EACJ,WAAW,EACX,WAAW,CAAC,cAAc,EAC1B,WAAW,CAAC,UAAU,CAAC,OAAO,EAC9B,QAAQ,CAAC,CAAC;YACd,GAAG,CAAC,CAAC,MAAM,OAAO,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC1C,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACzB,CAAC;YACD,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3B,CAAC;IACH,CAAC;AACH,CAAC;AAED,qCACI,QAA4B,EAC5B,IAAoB,EACpB,IAAyB,EACzB,OAAoC,EACpC,QAAmB;IACrB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAChB,MAAM,CAAC;IACT,CAAC;IACD,MAAM,YAAY,GAAG,uBAAuB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACzD,MAAM,mBAAmB,GACrB,QAAQ,CAAC,4BAA4B,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACjE,EAAE,CAAC,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;QACzB,MAAM,CAAC;IACT,CAAC;IACD,MAAM,eAAe,GACjB,QAAQ,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IAC/D,GAAG,CAAC,CAAC,MAAM,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC;QACvC,MAAM,sBAAsB,GAAG,WAAW,CAAC,UAAU,KAAK,CAAC;YACvD,WAAW,CAAC,QAAQ,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QACnD,IAAI,cAAc,GAAG,WAAW,CAAC,cAAc,CAAC;QAChD,IAAI,SAAS,GAAG,SAAS,CAAC;QAC1B,EAAE,CAAC,CAAC,WAAW,CAAC,SAAS,KAAK,GAAG,CAAC,CAAC,CAAC;YAClC,MAAM,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;YACjD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACV,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC1B,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,CAAC;QACH,CAAC;QACD,MAAM,WAAW,GAAG,QAAQ,CAAC,oBAAoB,CAC7C,WAAW,CAAC,UAAU,GAAG,eAAe,EACxC,WAAW,CAAC,QAAQ,GAAG,eAAe,CAAC,CAAC;QAE5C,MAAM,WAAW,GAAG,eAAe,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;QACjE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACjB,QAAQ,CAAC;QACX,CAAC;QACD,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACnC,QAAQ,CAAC,IAAI,CACT,IAAI,eAAO,iBAAE,cAAc,EAAE,QAAQ,IAAK,WAAW,CAAC,UAAU,EAAE,CAAC,CAAC;QAC1E,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,UAAU,GAAG,IAAI,8BAA8B,CACjD,IAAI,EACJ,sBAAsB,EACtB,WAAW,CAAC,SAAS,EACrB,SAAS,EACT,IAAI,EACJ,WAAW,EACX,cAAc,EACd,WAAW,CAAC,UAAU,CAAC,OAAO,EAC9B,QAAQ,CAAC,CAAC;YACd,GAAG,CAAC,CAAC,MAAM,OAAO,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC1C,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACzB,CAAC;YACD,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3B,CAAC;IACH,CAAC;AACH,CAAC;AAQD,iCAAiC,GAAW;IAC1C,MAAM,WAAW,GAAqB,EAAE,CAAC;IACzC,MAAM,OAAO,GAAG,UAAU,CAAC;IAC3B,IAAI,KAAK,CAAC;IACV,OAAO,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACjC,MAAM,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;QACnC,MAAM,SAAS,GAAG,cAAc,KAAK,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;QACtD,MAAM,OAAO,GAAG,cAAc,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;QACtD,MAAM,QAAQ,GAAG,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QAClD,EAAE,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACpB,mDAAmD;YACnD,KAAK,CAAC;QACR,CAAC;QACD,MAAM,cAAc,GAAG,GAAG,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QACvD,WAAW,CAAC,IAAI,CAAC,EAAC,UAAU,EAAE,QAAQ,EAAE,cAAc,EAAE,SAAS,EAAC,CAAC,CAAC;QAEpE,mEAAmE;QACnE,OAAO,CAAC,SAAS,GAAG,QAAQ,GAAG,CAAC,CAAC;IACnC,CAAC;IACD,MAAM,CAAC,WAAW,CAAC;AACrB,CAAC;AAED,uBAAuB,UAAkB;IACvC,MAAM,CAAC,UAAU;SAEZ,OAAO,CAAC,oDAAoD,EAAE,UAAU,CAAC;SAEzE,OAAO,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAC;AACtC,CAAC;AAED;;;GAGG;AACH,kCAAkC,UAAkB;IAClD,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAC;IAC1D,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;QACX,MAAM,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QAC7B,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;YACrB,uEAAuE;YACvE,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC7D,MAAM,CAAC,UAAU,GAAG,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;QACnE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,UAAU,CAAC;QACpB,CAAC;IACH,CAAC;IACD,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AACnC,CAAC;AAED,sBAAsB,MAAc;IAClC,MAAM,GAAG,GAAG,MAAM;SAED,OAAO,CAAC,UAAU,EAAE,GAAG,CAAC;SAIxB,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;IAC1C,kDAAkD;IAClD,MAAM,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAC9B,IAAI,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;IAChB,EAAE,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;QACf,EAAE,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAClB,CAAC;IACD,EAAE,CAAC,CAAC,EAAE,IAAI,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC;QAC3B,EAAE,GAAG,GAAG,CAAC;IACX,CAAC;IACD,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACX,KAAK,IAAI,CAAC;QACV,KAAK,GAAG;YACN,MAAM,CAAC,GAAG,CAAC;QACb,KAAK,GAAG;YACN,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IACD,EAAE,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;IAC5B,CAAC;IACD,MAAM,CAAC,GAAG,CAAC;AACb,CAAC;AAGD,yBAAyB,OAAe,EAAE,qBAAkC;IAC1E,MAAM,gBAAgB,GAAG;QACvB,IAAI,EAAE,qBAAqB,CAAC,KAAK,CAAC,IAAI;QACtC,GAAG,EAAE,qBAAqB,CAAC,KAAK,CAAC,MAAM;KACxC,CAAC;IACF,MAAM,WAAW,GAAG,2BAAO,CACvB,wBAAwB,CAAC,OAAO,CAAC,EACjC,qBAAqB,CAAC,IAAI,EAC1B,gBAAgB,EAChB,gCAAgC,CAAC,CAAC;IACtC,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;QACnC,MAAM,CAAC,WAAW,CAAC;IACrB,CAAC;IACD,yEAAyE;IACzE,6EAA6E;IAC7E,kEAAkE;IAClE,EAAE,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC/B,MAAM,CAAC,SAAS,CAAC;IACnB,CAAC;IACD,MAAM,CAAC,WAAW,CAAC;AACrB,CAAC;AAED,0CACI,QAA4B,EAC5B,aAAyB,EACzB,IAA8C;IAChD,MAAM,QAAQ,GAAc,EAAE,CAAC;IAC/B,MAAM,MAAM,GAAG;QACb,WAAW,EAAE,SAAwD;QACrE,QAAQ;KACT,CAAC;IACF,MAAM,qBAAqB,GAAG,QAAQ,CAAC,kBAAkB,CAAC,aAAa,CAAE,CAAC;IAE1E,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;QACpC,wEAAwE;QACxE,+DAA+D;QAC/D,QAAQ,CAAC,IAAI,CAAC,IAAI,eAAO,CAAC;YACxB,IAAI,EAAE,iCAAiC;YACvC,OAAO,EAAE,8DAA8D;YACvE,QAAQ,EAAE,gBAAQ,CAAC,IAAI;YACvB,WAAW,EAAE,qBAAqB;YAClC,cAAc,EAAE,QAAQ;SACzB,CAAC,CAAC,CAAC;QACJ,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IACD,MAAM,cAAc,GAAG,QAAQ,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC;IACjE,EAAE,CAAC,CAAC,OAAO,cAAc,KAAK,QAAQ,CAAC,CAAC,CAAC;QACvC,QAAQ,CAAC,IAAI,CAAC,IAAI,eAAO,CAAC;YACxB,IAAI,EAAE,4BAA4B;YAClC,OAAO,EAAE,4BAA4B,OAAO,cAAc,GAAG;YAC7D,WAAW,EAAE,qBAAqB;YAClC,QAAQ,EAAE,gBAAQ,CAAC,OAAO;YAC1B,cAAc,EAAE,QAAQ;SACzB,CAAC,CAAC,CAAC;QACJ,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IACD,MAAM,WAAW,GAAgB;QAC/B,IAAI,EAAE,qBAAqB,CAAC,IAAI;QAChC,KAAK,EAAE;YACL,MAAM,EAAE,qBAAqB,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC;YAC9C,IAAI,EAAE,qBAAqB,CAAC,KAAK,CAAC,IAAI;SACvC;QACD,GAAG,EAAE;YACH,MAAM,EAAE,qBAAqB,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC;YAC5C,IAAI,EAAE,qBAAqB,CAAC,GAAG,CAAC,IAAI;SACrC;KACF,CAAC;IACF,MAAM,MAAM,GAAG,eAAe,CAAC,cAAc,EAAE,WAAW,CAAC,CAAC;IAC5D,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;QACxC,QAAQ,CAAC,IAAI,CACT,IAAI,eAAO,iBAAE,cAAc,EAAE,QAAQ,IAAK,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;IACrE,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;QAC/C,MAAM,CAAC,WAAW,GAAG,IAAI,+BAA+B,CACpD,aAAa,EACb,WAAW,EACX,cAAc,EACd,MAAM,CAAC,UAAU,CAAC,OAAO,EACzB,IAAI,EACJ,QAAQ,CAAC,CAAC;QACd,GAAG,CAAC,CAAC,MAAM,OAAO,IAAI,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClD,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACzB,CAAC;IACH,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AA9DD,4EA8DC","file":"expression-scanner.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from 'babel-types';\nimport * as dom5 from 'dom5/lib/index-next';\nimport * as parse5 from 'parse5';\n\nimport {ParsedHtmlDocument} from '../html/html-document';\nimport * as astValue from '../javascript/ast-value';\nimport {JavaScriptDocument} from '../javascript/javascript-document';\nimport {parseJs} from '../javascript/javascript-parser';\nimport {correctSourceRange, LocationOffset, Severity, SourceRange, Warning} from '../model/model';\nimport {ParsedDocument} from '../parser/document';\n\nconst p = dom5.predicates;\nconst isTemplate = p.hasTagName('template');\n\nconst isDataBindingTemplate = p.AND(\n    isTemplate,\n    p.OR(\n        p.hasAttrValue('is', 'dom-bind'),\n        p.hasAttrValue('is', 'dom-if'),\n        p.hasAttrValue('is', 'dom-repeat'),\n        p.parentMatches(p.OR(\n            p.hasTagName('dom-bind'),\n            p.hasTagName('dom-if'),\n            p.hasTagName('dom-repeat'),\n            p.hasTagName('dom-module')))));\n\nexport interface Template extends parse5.ASTNode { content: parse5.ASTNode; }\n\n/**\n * Given a node, return all databinding templates inside it.\n *\n * A template is \"databinding\" if polymer databinding expressions are expected\n * to be evaluated inside. e.g. <template is='dom-if'> or <dom-module><template>\n *\n * Results include both direct and nested templates (e.g. dom-if inside\n * dom-module).\n */\nexport function getAllDataBindingTemplates(node: parse5.ASTNode) {\n  return dom5.queryAll(\n             node, isDataBindingTemplate, dom5.childNodesIncludeTemplate) as\n      IterableIterator<Template>;\n}\n\nexport type HtmlDatabindingExpression =\n    TextNodeDatabindingExpression|AttributeDatabindingExpression;\n\n/**\n * Some expressions are limited. For example, in a property declaration,\n * `observer` must be the identifier of a method, and `computed` must be a\n * function call expression.\n */\nexport type ExpressionLimitation = 'full'|'identifierOnly'|'callExpression';\nexport abstract class DatabindingExpression {\n  readonly sourceRange: SourceRange;\n  readonly warnings: Warning[] = [];\n  readonly expressionText: string;\n\n  private readonly _expressionAst: babel.Program;\n  private readonly locationOffset: LocationOffset;\n  private readonly _document: ParsedDocument;\n\n  /**\n   * Toplevel properties on the model that are referenced in this expression.\n   *\n   * e.g. in {{foo(bar, baz.zod)}} the properties are foo, bar, and baz\n   * (but not zod).\n   */\n  properties: Array<{name: string, sourceRange: SourceRange}> = [];\n\n  constructor(\n      sourceRange: SourceRange, expressionText: string, ast: babel.Program,\n      limitation: ExpressionLimitation, document: ParsedDocument) {\n    this.sourceRange = sourceRange;\n    this.expressionText = expressionText;\n    this._expressionAst = ast;\n    this.locationOffset = {\n      line: sourceRange.start.line,\n      col: sourceRange.start.column\n    };\n    this._document = document;\n    this._extractPropertiesAndValidate(limitation);\n  }\n\n  /**\n   * Given an estree node in this databinding expression, give its source range.\n   */\n  sourceRangeForNode(node: babel.Node) {\n    if (!node || !node.loc) {\n      return;\n    }\n    const databindingRelativeSourceRange = {\n      file: this.sourceRange.file,\n      // Note: estree uses 1-indexed lines, but SourceRange uses 0 indexed.\n      start: {line: (node.loc.start.line - 1), column: node.loc.start.column},\n      end: {line: (node.loc.end.line - 1), column: node.loc.end.column}\n    };\n    return correctSourceRange(\n        databindingRelativeSourceRange, this.locationOffset);\n  }\n\n  private _extractPropertiesAndValidate(limitation: ExpressionLimitation) {\n    if (this._expressionAst.body.length !== 1) {\n      this.warnings.push(this._validationWarning(\n          `Expected one expression, got ${this._expressionAst.body.length}`,\n          this._expressionAst));\n      return;\n    }\n    const expressionStatement = this._expressionAst.body[0]!;\n    if (!babel.isExpressionStatement(expressionStatement)) {\n      this.warnings.push(this._validationWarning(\n          `Expect an expression, not a ${expressionStatement.type}`,\n          expressionStatement));\n      return;\n    }\n    let expression = expressionStatement.expression;\n\n    this._validateLimitation(expression, limitation);\n    if (babel.isUnaryExpression(expression) && expression.operator === '!') {\n      expression = expression.argument;\n    }\n    this._extractAndValidateSubExpression(expression, true);\n  }\n\n  private _validateLimitation(\n      expression: babel.Expression, limitation: ExpressionLimitation) {\n    switch (limitation) {\n      case 'identifierOnly':\n        if (!babel.isIdentifier(expression)) {\n          this.warnings.push(this._validationWarning(\n              `Expected just a name here, not an expression`, expression));\n        }\n        break;\n      case 'callExpression':\n        if (!babel.isCallExpression(expression)) {\n          this.warnings.push(this._validationWarning(\n              `Expected a function call here.`, expression));\n        }\n        break;\n      case 'full':\n        break;  // no checks needed\n      default:\n        const never: never = limitation;\n        throw new Error(`Got unknown limitation: ${never}`);\n    }\n  }\n\n  private _extractAndValidateSubExpression(\n      expression: babel.Node, callAllowed: boolean): void {\n    if (babel.isUnaryExpression(expression) && expression.operator === '-') {\n      if (!babel.isNumericLiteral(expression.argument)) {\n        this.warnings.push(this._validationWarning(\n            'The - operator is only supported for writing negative numbers.',\n            expression));\n        return;\n      }\n      this._extractAndValidateSubExpression(expression.argument, false);\n      return;\n    }\n    if (babel.isLiteral(expression)) {\n      return;\n    }\n    if (babel.isIdentifier(expression)) {\n      this.properties.push({\n        name: expression.name,\n        sourceRange: this.sourceRangeForNode(expression)!\n      });\n      return;\n    }\n    if (babel.isMemberExpression(expression)) {\n      this._extractAndValidateSubExpression(expression.object, false);\n      return;\n    }\n    if (callAllowed && babel.isCallExpression(expression)) {\n      this._extractAndValidateSubExpression(expression.callee, false);\n      for (const arg of expression.arguments) {\n        this._extractAndValidateSubExpression(arg, false);\n      }\n      return;\n    }\n    this.warnings.push(this._validationWarning(\n        `Only simple syntax is supported in Polymer databinding expressions. ` +\n            `${expression.type} not expected here.`,\n        expression));\n  }\n\n  private _validationWarning(message: string, node: babel.Node): Warning {\n    return new Warning({\n      code: 'invalid-polymer-expression',\n      message,\n      sourceRange: this.sourceRangeForNode(node)!,\n      severity: Severity.WARNING,\n      parsedDocument: this._document,\n    });\n  }\n}\n\nexport class AttributeDatabindingExpression extends DatabindingExpression {\n  /**\n   * The element whose attribute/property is assigned to.\n   */\n  readonly astNode: parse5.ASTNode;\n\n  readonly databindingInto = 'attribute';\n\n  /**\n   * If true, this is databinding into the complete attribute. Polymer treats\n   * such databindings specially, e.g. they're setting the property by default,\n   * not the attribute.\n   *\n   * e.g.\n   * foo=\"{{bar}}\" is complete, foo=\"hello {{bar}} world\" is not complete.\n   *\n   * An attribute may have multiple incomplete bindings. They will be separate\n   * AttributeDatabindingExpressions.\n   */\n  readonly isCompleteBinding: boolean;\n\n  /** The databinding syntax used. */\n  readonly direction: '{'|'[';\n\n  /**\n   * If this is a two-way data binding, and an event name was specified\n   * (using ::eventName syntax), this is that event name.\n   */\n  readonly eventName: string|undefined;\n\n  /** The attribute we're databinding into. */\n  readonly attribute: parse5.ASTAttribute;\n\n  constructor(\n      astNode: parse5.ASTNode, isCompleteBinding: boolean, direction: '{'|'[',\n      eventName: string|undefined, attribute: parse5.ASTAttribute,\n      sourceRange: SourceRange, expressionText: string, ast: babel.Program,\n      document: ParsedHtmlDocument) {\n    super(sourceRange, expressionText, ast, 'full', document);\n    this.astNode = astNode;\n    this.isCompleteBinding = isCompleteBinding;\n    this.direction = direction;\n    this.eventName = eventName;\n    this.attribute = attribute;\n  }\n}\n\nexport class TextNodeDatabindingExpression extends DatabindingExpression {\n  /** The databinding syntax used. */\n  readonly direction: '{'|'[';\n\n  /**\n   * The HTML text node that contains this databinding.\n   */\n  readonly astNode: parse5.ASTNode;\n\n  readonly databindingInto = 'text-node';\n\n  constructor(\n      direction: '{'|'[', astNode: parse5.ASTNode, sourceRange: SourceRange,\n      expressionText: string, ast: babel.Program,\n      document: ParsedHtmlDocument) {\n    super(sourceRange, expressionText, ast, 'full', document);\n    this.direction = direction;\n    this.astNode = astNode;\n  }\n}\n\nexport class JavascriptDatabindingExpression extends DatabindingExpression {\n  readonly astNode: babel.Node;\n\n  readonly databindingInto = 'javascript';\n\n  constructor(\n      astNode: babel.Node, sourceRange: SourceRange, expressionText: string,\n      ast: babel.Program, kind: ExpressionLimitation,\n      document: JavaScriptDocument) {\n    super(sourceRange, expressionText, ast, kind, document);\n    this.astNode = astNode;\n  }\n}\n\n/**\n * Find and parse Polymer databinding expressions in HTML.\n */\nexport function scanDocumentForExpressions(document: ParsedHtmlDocument) {\n  return extractDataBindingsFromTemplates(\n      document, getAllDataBindingTemplates(document.ast));\n}\n\nexport function scanDatabindingTemplateForExpressions(\n    document: ParsedHtmlDocument, template: Template) {\n  return extractDataBindingsFromTemplates(\n      document,\n      [template].concat([...getAllDataBindingTemplates(template.content)]));\n}\n\nfunction extractDataBindingsFromTemplates(\n    document: ParsedHtmlDocument, templates: Iterable<Template>) {\n  const results: HtmlDatabindingExpression[] = [];\n  const warnings: Warning[] = [];\n  for (const template of templates) {\n    for (const node of dom5.depthFirst(template.content)) {\n      if (dom5.isTextNode(node) && node.value) {\n        extractDataBindingsFromTextNode(document, node, results, warnings);\n      }\n      if (node.attrs) {\n        for (const attr of node.attrs) {\n          extractDataBindingsFromAttr(document, node, attr, results, warnings);\n        }\n      }\n    }\n  }\n  return {expressions: results, warnings};\n}\n\nfunction extractDataBindingsFromTextNode(\n    document: ParsedHtmlDocument,\n    node: parse5.ASTNode,\n    results: HtmlDatabindingExpression[],\n    warnings: Warning[]) {\n  const text = node.value || '';\n  const dataBindings = findDatabindingInString(text);\n  if (dataBindings.length === 0) {\n    return;\n  }\n  const nodeSourceRange = document.sourceRangeForNode(node);\n  if (!nodeSourceRange) {\n    return;\n  }\n\n  const startOfTextNodeOffset =\n      document.sourcePositionToOffset(nodeSourceRange.start);\n  for (const dataBinding of dataBindings) {\n    const sourceRange = document.offsetsToSourceRange(\n        dataBinding.startIndex + startOfTextNodeOffset,\n        dataBinding.endIndex + startOfTextNodeOffset);\n\n    const parseResult =\n        parseExpression(dataBinding.expressionText, sourceRange);\n\n    if (!parseResult) {\n      continue;\n    }\n    if (parseResult.type === 'failure') {\n      warnings.push(\n          new Warning({parsedDocument: document, ...parseResult.warningish}));\n    } else {\n      const expression = new TextNodeDatabindingExpression(\n          dataBinding.direction,\n          node,\n          sourceRange,\n          dataBinding.expressionText,\n          parseResult.parsedFile.program,\n          document);\n      for (const warning of expression.warnings) {\n        warnings.push(warning);\n      }\n      results.push(expression);\n    }\n  }\n}\n\nfunction extractDataBindingsFromAttr(\n    document: ParsedHtmlDocument,\n    node: parse5.ASTNode,\n    attr: parse5.ASTAttribute,\n    results: HtmlDatabindingExpression[],\n    warnings: Warning[]) {\n  if (!attr.value) {\n    return;\n  }\n  const dataBindings = findDatabindingInString(attr.value);\n  const attributeValueRange =\n      document.sourceRangeForAttributeValue(node, attr.name, true);\n  if (!attributeValueRange) {\n    return;\n  }\n  const attributeOffset =\n      document.sourcePositionToOffset(attributeValueRange.start);\n  for (const dataBinding of dataBindings) {\n    const isFullAttributeBinding = dataBinding.startIndex === 2 &&\n        dataBinding.endIndex + 2 === attr.value.length;\n    let expressionText = dataBinding.expressionText;\n    let eventName = undefined;\n    if (dataBinding.direction === '{') {\n      const match = expressionText.match(/(.*)::(.*)/);\n      if (match) {\n        expressionText = match[1];\n        eventName = match[2];\n      }\n    }\n    const sourceRange = document.offsetsToSourceRange(\n        dataBinding.startIndex + attributeOffset,\n        dataBinding.endIndex + attributeOffset);\n\n    const parseResult = parseExpression(expressionText, sourceRange);\n    if (!parseResult) {\n      continue;\n    }\n    if (parseResult.type === 'failure') {\n      warnings.push(\n          new Warning({parsedDocument: document, ...parseResult.warningish}));\n    } else {\n      const expression = new AttributeDatabindingExpression(\n          node,\n          isFullAttributeBinding,\n          dataBinding.direction,\n          eventName,\n          attr,\n          sourceRange,\n          expressionText,\n          parseResult.parsedFile.program,\n          document);\n      for (const warning of expression.warnings) {\n        warnings.push(warning);\n      }\n      results.push(expression);\n    }\n  }\n}\n\ninterface RawDatabinding {\n  readonly expressionText: string;\n  readonly startIndex: number;\n  readonly endIndex: number;\n  readonly direction: '{'|'[';\n}\nfunction findDatabindingInString(str: string) {\n  const expressions: RawDatabinding[] = [];\n  const openers = /{{|\\[\\[/g;\n  let match;\n  while (match = openers.exec(str)) {\n    const matchedOpeners = match[0];\n    const startIndex = match.index + 2;\n    const direction = matchedOpeners === '{{' ? '{' : '[';\n    const closers = matchedOpeners === '{{' ? '}}' : ']]';\n    const endIndex = str.indexOf(closers, startIndex);\n    if (endIndex === -1) {\n      // No closers, this wasn't an expression after all.\n      break;\n    }\n    const expressionText = str.slice(startIndex, endIndex);\n    expressions.push({startIndex, endIndex, expressionText, direction});\n\n    // Start looking for the next expression after the end of this one.\n    openers.lastIndex = endIndex + 2;\n  }\n  return expressions;\n}\n\nfunction transformPath(expression: string) {\n  return expression\n      // replace .0, .123, .kebab-case with ['0'], ['123'], ['kebab-case']\n      .replace(/\\.([a-zA-Z_$]([\\w:$*]*-+[\\w:$*]*)+|[1-9][0-9]*|0)/g, '[\\'$1\\']')\n      // remove .* and .splices from the end of the paths\n      .replace(/\\.(\\*|splices)$/, '');\n}\n\n/**\n * Transform polymer expression based on\n * https://github.com/Polymer/polymer/blob/10aded461b1a107ed1cfc4a1d630149ad8508bda/lib/mixins/property-effects.html#L864\n */\nfunction transformPolymerExprToJS(expression: string) {\n  const method = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n  if (method) {\n    const methodName = method[1];\n    if (method[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      const args = method[2].replace(/\\\\,/g, '&comma;').split(',');\n      return methodName + '(' + args.map(transformArg).join(',') + ')';\n    } else {\n      return expression;\n    }\n  }\n  return transformPath(expression);\n}\n\nfunction transformArg(rawArg: string) {\n  const arg = rawArg\n                  // replace comma entity with comma\n                  .replace(/&comma;/g, ',')\n                  // repair extra escape sequences; note only commas strictly\n                  // need escaping, but we allow any other char to be escaped\n                  // since its likely users will do this\n                  .replace(/\\\\(.)/g, '\\$1');\n  // detect literal value (must be String or Number)\n  const i = arg.search(/[^\\s]/);\n  let fc = arg[i];\n  if (fc === '-') {\n    fc = arg[i + 1];\n  }\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n  switch (fc) {\n    case '\\'':\n    case '\"':\n      return arg;\n    case '#':\n      return arg;\n  }\n  if (arg.indexOf('.') !== -1) {\n    return transformPath(arg);\n  }\n  return arg;\n}\n\n\nfunction parseExpression(content: string, expressionSourceRange: SourceRange) {\n  const expressionOffset = {\n    line: expressionSourceRange.start.line,\n    col: expressionSourceRange.start.column\n  };\n  const parseResult = parseJs(\n      transformPolymerExprToJS(content),\n      expressionSourceRange.file,\n      expressionOffset,\n      'polymer-expression-parse-error');\n  if (parseResult.type === 'success') {\n    return parseResult;\n  }\n  // The polymer databinding expression language allows for foo.0 and foo.*\n  // formats when accessing sub properties. These aren't valid JS, but we don't\n  // want to warn for them either. So just return undefined for now.\n  if (/\\.(\\*|\\d+)/.test(content)) {\n    return undefined;\n  }\n  return parseResult;\n}\n\nexport function parseExpressionInJsStringLiteral(\n    document: JavaScriptDocument,\n    stringLiteral: babel.Node,\n    kind: 'identifierOnly'|'callExpression'|'full') {\n  const warnings: Warning[] = [];\n  const result = {\n    databinding: undefined as undefined | JavascriptDatabindingExpression,\n    warnings\n  };\n  const sourceRangeForLiteral = document.sourceRangeForNode(stringLiteral)!;\n\n  if (!babel.isLiteral(stringLiteral)) {\n    // Should we warn here? It's potentially valid, just unanalyzable. Maybe\n    // just an info that someone could escalate to a warning/error?\n    warnings.push(new Warning({\n      code: 'unanalyzable-polymer-expression',\n      message: `Can only analyze databinding expressions in string literals.`,\n      severity: Severity.INFO,\n      sourceRange: sourceRangeForLiteral,\n      parsedDocument: document\n    }));\n    return result;\n  }\n  const expressionText = astValue.expressionToValue(stringLiteral);\n  if (typeof expressionText !== 'string') {\n    warnings.push(new Warning({\n      code: 'invalid-polymer-expression',\n      message: `Expected a string, got a ${typeof expressionText}.`,\n      sourceRange: sourceRangeForLiteral,\n      severity: Severity.WARNING,\n      parsedDocument: document\n    }));\n    return result;\n  }\n  const sourceRange: SourceRange = {\n    file: sourceRangeForLiteral.file,\n    start: {\n      column: sourceRangeForLiteral.start.column + 1,\n      line: sourceRangeForLiteral.start.line\n    },\n    end: {\n      column: sourceRangeForLiteral.end.column - 1,\n      line: sourceRangeForLiteral.end.line\n    }\n  };\n  const parsed = parseExpression(expressionText, sourceRange);\n  if (parsed && parsed.type === 'failure') {\n    warnings.push(\n        new Warning({parsedDocument: document, ...parsed.warningish}));\n  } else if (parsed && parsed.type === 'success') {\n    result.databinding = new JavascriptDatabindingExpression(\n        stringLiteral,\n        sourceRange,\n        expressionText,\n        parsed.parsedFile.program,\n        kind,\n        document);\n    for (const warning of result.databinding.warnings) {\n      warnings.push(warning);\n    }\n  }\n  return result;\n}\n"]}