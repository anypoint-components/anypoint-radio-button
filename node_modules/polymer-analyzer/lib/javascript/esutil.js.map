{"version":3,"sources":["javascript/esutil.ts"],"names":[],"mappings":"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","file":"esutil.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport generate from 'babel-generator';\nimport * as babel from 'babel-types';\nimport * as doctrine from 'doctrine';\n\nimport {MethodParam, ScannedMethod, ScannedProperty} from '../index';\nimport {Result} from '../model/analysis';\nimport {ImmutableSet} from '../model/immutable';\nimport {Privacy} from '../model/model';\nimport {ScannedEvent, Severity, SourceRange, Warning} from '../model/model';\nimport {ParsedDocument} from '../parser/document';\nimport * as docs from '../polymer/docs';\nimport {annotateEvent} from '../polymer/docs';\n\nimport * as astValue from './ast-value';\nimport * as estraverse from './estraverse-shim';\nimport {JavaScriptDocument} from './javascript-document';\nimport * as jsdoc from './jsdoc';\n\n/**\n * Returns whether a Babel node matches a particular object path.\n *\n * e.g. you have a MemberExpression node, and want to see whether it represents\n * `Foo.Bar.Baz`:\n *    matchesCallExpressio\n    (node, ['Foo', 'Bar', 'Baz'])\n *\n * @param {babel.Node} expression The Babel node to match against.\n * @param {Array<string>} path The path to look for.\n */\nexport function matchesCallExpression(\n    expression: babel.MemberExpression, path: string[]): boolean {\n  if (!expression.property || !expression.object) {\n    return false;\n  }\n  console.assert(path.length >= 2);\n\n  if (!babel.isIdentifier(expression.property)) {\n    return false;\n  }\n  // Unravel backwards, make sure properties match each step of the way.\n  if (expression.property.name !== path[path.length - 1]) {\n    return false;\n  }\n  // We've got ourselves a final member expression.\n  if (path.length === 2 && babel.isIdentifier(expression.object)) {\n    return expression.object.name === path[0];\n  }\n  // Nested expressions.\n  if (path.length > 2 && babel.isMemberExpression(expression.object)) {\n    return matchesCallExpression(\n        expression.object, path.slice(0, path.length - 1));\n  }\n\n  return false;\n}\n\n/**\n * Given a property or method, return its name, or undefined if that name can't\n * be determined.\n */\nexport function getPropertyName(prop: babel.ObjectProperty|\n                                babel.ObjectMethod|babel.ClassMethod|\n                                babel.SpreadProperty): string|undefined {\n  if (babel.isSpreadProperty(prop)) {\n    return undefined;\n  }\n  const key = prop.key;\n  // {foo: bar} // note that `foo` is not quoted, so it's an identifier\n  if (!prop.computed && babel.isIdentifier(key)) {\n    return key.name;\n  }\n\n  // Otherwise, try to statically evaluate the expression\n  const keyValue = astValue.expressionToValue(key);\n  if (keyValue !== undefined) {\n    return '' + keyValue;\n  }\n  return undefined;\n}\n\nexport const CLOSURE_CONSTRUCTOR_MAP = new Map(\n    [['Boolean', 'boolean'], ['Number', 'number'], ['String', 'string']]);\n\nconst VALID_EXPRESSION_TYPES = new Map([\n  ['ArrayExpression', 'Array'],\n  ['BlockStatement', 'Function'],\n  ['BooleanLiteral', 'boolean'],\n  ['FunctionExpression', 'Function'],\n  ['NullLiteral', 'null'],\n  ['NumericLiteral', 'number'],\n  ['ObjectExpression', 'Object'],\n  ['RegExpLiteral', 'RegExp'],\n  ['StringLiteral', 'string'],\n  ['TemplateLiteral', 'string'],\n]);\n\n/**\n * AST expression -> Closure type.\n *\n * Accepts literal values, and native constructors.\n *\n * @param {Node} node A Babel expression node.\n * @return {string} The type of that expression, in Closure terms.\n */\nexport function getClosureType(\n    node: babel.Node,\n    parsedJsdoc: doctrine.Annotation|undefined,\n    sourceRange: SourceRange,\n    document: ParsedDocument): Result<string, Warning> {\n  if (parsedJsdoc) {\n    const typeTag = jsdoc.getTag(parsedJsdoc, 'type');\n    if (typeTag) {\n      return {successful: true, value: doctrine.type.stringify(typeTag.type!)};\n    }\n  }\n  const type = VALID_EXPRESSION_TYPES.get(node.type);\n  if (type) {\n    return {successful: true, value: type};\n  }\n  if (babel.isIdentifier(node)) {\n    return {\n      successful: true,\n      value: CLOSURE_CONSTRUCTOR_MAP.get(node.name) || node.name\n    };\n  }\n  const warning = new Warning({\n    code: 'no-closure-type',\n    message: `Unable to determine closure type for expression of type ` +\n        `${node.type}`,\n    severity: Severity.WARNING,\n    sourceRange,\n    parsedDocument: document,\n  });\n  return {successful: false, error: warning};\n}\n\nexport function getAttachedComment(node: babel.Node): string|undefined {\n  const comments = getLeadingComments(node) || [];\n  return comments && comments[comments.length - 1];\n}\n\n/**\n * Returns all comments from a tree defined with @event.\n */\nexport function getEventComments(node: babel.Node): Map<string, ScannedEvent> {\n  const eventComments = new Set<string>();\n  estraverse.traverse(node, {\n    enter(node: babel.Node) {\n      (node.leadingComments || [])\n          .concat(node.trailingComments || [])\n          .map((commentAST) => commentAST.value)\n          .filter((comment) => comment.indexOf('@event') !== -1)\n          .forEach((comment) => eventComments.add(comment));\n    }\n  });\n  const events = [...eventComments]\n                     .map(\n                         (comment) => annotateEvent(jsdoc.parseJsdoc(\n                             jsdoc.removeLeadingAsterisks(comment).trim())))\n                     .filter((ev) => !!ev)\n                     .sort((ev1, ev2) => ev1.name.localeCompare(ev2.name));\n  return new Map(events.map((e) => [e.name, e] as [string, ScannedEvent]));\n}\n\nfunction getLeadingComments(node: babel.Node): string[]|undefined {\n  if (!node) {\n    return;\n  }\n  const comments = [];\n  for (const comment of node.leadingComments || []) {\n    // Espree says any comment that immediately precedes a node is\n    // \"leading\", but we want to be stricter and require them to be\n    // touching. If we don't have locations for some reason, err on the\n    // side of including the comment.\n    if (!node.loc || !comment.loc ||\n        node.loc.start.line - comment.loc.end.line < 2) {\n      comments.push(comment.value);\n    }\n  }\n  return comments.length ? comments : undefined;\n}\n\nexport function getPropertyValue(\n    node: babel.ObjectExpression, name: string): babel.Node|undefined {\n  const properties = node.properties;\n  for (const property of properties) {\n    if (!babel.isSpreadProperty(property) &&\n        getPropertyName(property) === name) {\n      return property.value;\n    }\n  }\n}\n\n/**\n * Create a ScannedMethod object from an estree Property AST node.\n */\nexport function toScannedMethod(\n    node: babel.ObjectProperty|babel.ObjectMethod|babel.ClassMethod,\n    sourceRange: SourceRange,\n    document: ParsedDocument): ScannedMethod {\n  const parsedJsdoc = jsdoc.parseJsdoc(getAttachedComment(node) || '');\n  const description = parsedJsdoc.description.trim();\n  const maybeName = getPropertyName(node);\n\n  const warnings: Warning[] = [];\n  if (!maybeName) {\n    warnings.push(new Warning({\n      code: 'unknown-method-name',\n      message: `Could not determine name of method from expression of type: ` +\n          `${node.key.type}`,\n      sourceRange: sourceRange,\n      severity: Severity.INFO,\n      parsedDocument: document\n    }));\n  }\n\n  const value = babel.isObjectProperty(node) ? node.value : node;\n\n  const result = getClosureType(value, parsedJsdoc, sourceRange, document);\n  const type = result.successful === true ? result.value : 'Function';\n\n  const name = maybeName || '';\n  const scannedMethod: ScannedMethod = {\n    name,\n    type,\n    description,\n    sourceRange,\n    warnings,\n    astNode: node,\n    jsdoc: parsedJsdoc,\n    privacy: getOrInferPrivacy(name, parsedJsdoc)\n  };\n\n  if (value && babel.isFunction(value)) {\n    if (scannedMethod.jsdoc !== undefined) {\n      scannedMethod.return = getReturnFromAnnotation(scannedMethod.jsdoc);\n    }\n    if (scannedMethod.return === undefined) {\n      scannedMethod.return = inferReturnFromBody(value);\n    }\n\n    scannedMethod.params =\n        (value.params ||\n         []).map((nodeParam) => toMethodParam(nodeParam, scannedMethod.jsdoc));\n  }\n\n  return scannedMethod;\n}\n\nexport function getReturnFromAnnotation(jsdocAnn: jsdoc.Annotation):\n    {type?: string, desc?: string}|undefined {\n  const tag =\n      jsdoc.getTag(jsdocAnn, 'return') || jsdoc.getTag(jsdocAnn, 'returns');\n\n  if (!tag || (!tag.type && !tag.description)) {\n    return undefined;\n  }\n\n  const type: {type?: string, desc?: string} = {};\n\n  if (tag && (tag.type || tag.description)) {\n    if (tag.type) {\n      type.type = doctrine.type.stringify(tag.type);\n    }\n    if (tag.description) {\n      type.desc = tag.description;\n    }\n  }\n\n  return type;\n}\n\n/**\n * Examine the body of a function to see if we can infer something about its\n * return type. This currently only handles the case where a function definitely\n * returns void.\n */\nexport function inferReturnFromBody(node: babel.Function): {type: string}|\n    undefined {\n  if (node.async === true || node.generator === true) {\n    // Async functions always return promises, and generators always return\n    // iterators, so they are never void.\n    return undefined;\n  }\n  if (babel.isArrowFunctionExpression(node) &&\n      !babel.isBlockStatement(node.body)) {\n    // An arrow function that immediately returns a value (e.g. () => 'foo').\n    return undefined;\n  }\n  let returnsVoid = true;\n  estraverse.traverse(node, {\n    enterReturnStatement(statement: babel.ReturnStatement) {\n      // The typings claim that statement.argument is always an Expression, but\n      // actually when there is no argument it is null.\n      if (statement.argument !== null) {\n        returnsVoid = false;\n        return estraverse.VisitorOption.Break;\n      }\n    },\n    // If this function contains another function, don't traverse into it. Only\n    // return statements in the immediate function scope matter.\n    enterFunctionDeclaration() {\n      return estraverse.VisitorOption.Skip;\n    },\n    enterFunctionExpression() {\n      return estraverse.VisitorOption.Skip;\n    },\n    enterClassMethod() {\n      return estraverse.VisitorOption.Skip;\n    },\n    enterArrowFunctionExpression() {\n      return estraverse.VisitorOption.Skip;\n    },\n    enterObjectMethod() {\n      return estraverse.VisitorOption.Skip;\n    },\n  });\n  if (returnsVoid) {\n    return {type: 'void'};\n  }\n  return undefined;\n}\n\nexport function toMethodParam(\n    nodeParam: babel.LVal, jsdocAnn?: jsdoc.Annotation): MethodParam {\n  const paramTags = new Map<string, doctrine.Tag>();\n  let name;\n  let defaultValue;\n  let rest;\n\n  if (jsdocAnn) {\n    for (const tag of (jsdocAnn.tags || [])) {\n      if (tag.title === 'param' && tag.name) {\n        paramTags.set(tag.name, tag);\n      }\n    }\n  }\n\n  if (babel.isIdentifier(nodeParam)) {\n    // Basic parameter: method(param)\n    name = nodeParam.name;\n\n  } else if (\n      babel.isRestElement(nodeParam) &&\n      babel.isIdentifier(nodeParam.argument)) {\n    // Rest parameter: method(...param)\n    name = nodeParam.argument.name;\n    rest = true;\n\n  } else if (\n      babel.isAssignmentPattern(nodeParam) &&\n      babel.isIdentifier(nodeParam.left) && babel.isLiteral(nodeParam.right)) {\n    // Parameter with a default: method(param = \"default\")\n    name = nodeParam.left.name;\n    defaultValue = generate(nodeParam.right).code;\n\n  } else {\n    // Some AST pattern we don't recognize. Hope the code generator does\n    // something reasonable.\n    name = generate(nodeParam).code;\n  }\n\n  let type;\n  let description;\n  const tag = paramTags.get(name);\n  if (tag) {\n    if (tag.type) {\n      type = doctrine.type.stringify(tag.type);\n    }\n    if (tag.description) {\n      description = tag.description;\n    }\n  }\n\n  const param: MethodParam = {name, type, defaultValue, rest, description};\n  return param;\n}\n\nexport function getOrInferPrivacy(\n    name: string,\n    annotation: jsdoc.Annotation|undefined,\n    defaultPrivacy: Privacy = 'public'): Privacy {\n  const explicitPrivacy = jsdoc.getPrivacy(annotation);\n  const specificName = name.slice(name.lastIndexOf('.') + 1);\n\n  if (explicitPrivacy) {\n    return explicitPrivacy;\n  }\n  if (specificName.startsWith('__')) {\n    return 'private';\n  } else if (specificName.startsWith('_')) {\n    return 'protected';\n  } else if (specificName.endsWith('_')) {\n    return 'private';\n  } else if (configurationProperties.has(specificName)) {\n    return 'protected';\n  }\n  return defaultPrivacy;\n}\n\n/**\n * Properties on element prototypes that are part of the custom elment\n * lifecycle or Polymer configuration syntax.\n *\n * TODO(rictic): only treat the Polymer ones as private when dealing with\n *   Polymer.\n */\nexport const configurationProperties: ImmutableSet<string> = new Set([\n  'attached',\n  'attributeChanged',\n  'beforeRegister',\n  'configure',\n  'constructor',\n  'created',\n  'detached',\n  'enableCustomStyleProperties',\n  'extends',\n  'hostAttributes',\n  'is',\n  'listeners',\n  'mixins',\n  'observers',\n  'properties',\n  'ready',\n  'registered',\n]);\n\n/**\n * Scan any methods on the given node, if it's a class expression/declaration.\n */\nexport function getMethods(node: babel.Node, document: JavaScriptDocument):\n    Map<string, ScannedMethod> {\n  const methods = new Map<string, ScannedMethod>();\n  for (const statement of _getMethods(node)) {\n    if (statement.static === false) {\n      const method = toScannedMethod(\n          statement, document.sourceRangeForNode(statement)!, document);\n      docs.annotate(method);\n      methods.set(method.name, method);\n    }\n  }\n  return methods;\n}\n\n/**\n * Scan any static methods on the given node, if it's a class\n * expression/declaration.\n */\nexport function getStaticMethods(\n    node: babel.Node,\n    document: JavaScriptDocument): Map<string, ScannedMethod> {\n  const methods = new Map<string, ScannedMethod>();\n  for (const method of _getMethods(node)) {\n    if (method.static === true) {\n      const scannedMethod = toScannedMethod(\n          method, document.sourceRangeForNode(method)!, document);\n      docs.annotate(scannedMethod);\n      methods.set(scannedMethod.name, scannedMethod);\n    }\n  }\n  return methods;\n}\n\nfunction* _getMethods(node: babel.Node) {\n  if (!babel.isClassDeclaration(node) && !babel.isClassExpression(node)) {\n    return;\n  }\n  for (const statement of node.body.body) {\n    if (babel.isClassMethod(statement) && statement.kind === 'method') {\n      yield statement;\n    }\n  }\n}\n\n/*\n * Extracts a property from a given getter or setter method,\n * whether it be an object method or a class method.\n */\nexport function extractPropertyFromGetterOrSetter(\n    method: babel.ClassMethod|babel.ObjectMethod,\n    jsdocAnn: jsdoc.Annotation|undefined,\n    document: JavaScriptDocument): ScannedProperty|null {\n  // TODO(43081j): remove this when static properties are supported\n  if (babel.isClassMethod(method) && method.static) {\n    return null;\n  }\n\n  if (method.kind !== 'get' && method.kind !== 'set') {\n    return null;\n  }\n\n  // TODO(43081j): use getPropertyName, see\n  // https://github.com/Polymer/polymer-analyzer/pull/867\n  const name = getPropertyName(method);\n  if (name === undefined) {\n    return null;\n  }\n\n  let type;\n  let description;\n  let privacy: Privacy = 'public';\n  let readOnly = false;\n\n  if (jsdocAnn) {\n    const ret = getReturnFromAnnotation(jsdocAnn);\n    type = ret ? ret.type : undefined;\n    description = jsdoc.getDescription(jsdocAnn);\n    privacy = getOrInferPrivacy(name, jsdocAnn);\n    readOnly = jsdoc.hasTag(jsdocAnn, 'readonly');\n  }\n\n  return {\n    name,\n    astNode: method,\n    type,\n    jsdoc: jsdocAnn,\n    sourceRange: document.sourceRangeForNode(method)!,\n    description,\n    privacy,\n    warnings: [],\n    readOnly,\n  };\n}\n\n/**\n * Extracts properties (including accessors) from a given class\n * or object expression.\n */\nexport function extractPropertiesFromClassOrObjectBody(\n    node: babel.Class|babel.ObjectExpression,\n    document: JavaScriptDocument): Map<string, ScannedProperty> {\n  const properties = new Map<string, ScannedProperty>();\n  const accessors = new Map<string, {\n    getter?: babel.ClassMethod | babel.ObjectMethod,\n    setter?: babel.ClassMethod | babel.ObjectMethod\n  }>();\n\n  let body;\n\n  if (babel.isClass(node)) {\n    body = node.body.body;\n  } else {\n    body = node.properties;\n  }\n\n  for (const member of body) {\n    if (babel.isSpreadProperty(member)) {\n      continue;\n    }\n\n    if ((babel.isMethod(member) || babel.isObjectProperty(member)) &&\n        member.computed) {\n      continue;\n    }\n\n    const name = astValue.getIdentifierName(member.key)!;\n\n    if (babel.isMethod(member) || babel.isFunction(member.value)) {\n      if (babel.isMethod(member) &&\n          (member.kind === 'get' || member.kind === 'set')) {\n        let accessor = accessors.get(name);\n\n        if (!accessor) {\n          accessor = {};\n          accessors.set(name, accessor);\n        }\n\n        if (member.kind === 'get') {\n          accessor.getter = member;\n        } else {\n          accessor.setter = member;\n        }\n      }\n\n      continue;\n    }\n\n    const astNode = member.key;\n    const sourceRange = document.sourceRangeForNode(member)!;\n    const jsdocAnn = jsdoc.parseJsdoc(getAttachedComment(member) || '');\n    const detectedType =\n        getClosureType(member.value, jsdocAnn, sourceRange, document);\n    let type: string|undefined = undefined;\n\n    if (detectedType.successful) {\n      type = detectedType.value;\n    }\n\n    properties.set(name, {\n      name,\n      astNode,\n      type,\n      jsdoc: jsdocAnn,\n      sourceRange,\n      description: jsdocAnn ? jsdoc.getDescription(jsdocAnn) : undefined,\n      privacy: getOrInferPrivacy(name, jsdocAnn),\n      warnings: [],\n      readOnly: jsdoc.hasTag(jsdocAnn, 'readonly'),\n    });\n  }\n\n  for (const val of accessors.values()) {\n    let getter: ScannedProperty|null = null;\n    let setter: ScannedProperty|null = null;\n\n    if (val.getter) {\n      const parsedJsdoc =\n          jsdoc.parseJsdoc(getAttachedComment(val.getter) || '');\n      getter =\n          extractPropertyFromGetterOrSetter(val.getter, parsedJsdoc, document);\n    }\n\n    if (val.setter) {\n      const parsedJsdoc =\n          jsdoc.parseJsdoc(getAttachedComment(val.setter) || '');\n      setter =\n          extractPropertyFromGetterOrSetter(val.setter, parsedJsdoc, document);\n    }\n\n    const prop = getter || setter;\n    if (!prop) {\n      continue;\n    }\n\n    if (!prop.readOnly) {\n      prop.readOnly = (val.setter === undefined);\n    }\n\n    properties.set(prop.name, prop);\n  }\n\n  return properties;\n}\n"]}