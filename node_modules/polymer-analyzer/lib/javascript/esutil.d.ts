import * as babel from 'babel-types';
import * as doctrine from 'doctrine';
import { MethodParam, ScannedMethod, ScannedProperty } from '../index';
import { Result } from '../model/analysis';
import { ImmutableSet } from '../model/immutable';
import { Privacy } from '../model/model';
import { ScannedEvent, SourceRange, Warning } from '../model/model';
import { ParsedDocument } from '../parser/document';
import { JavaScriptDocument } from './javascript-document';
import * as jsdoc from './jsdoc';
/**
 * Returns whether a Babel node matches a particular object path.
 *
 * e.g. you have a MemberExpression node, and want to see whether it represents
 * `Foo.Bar.Baz`:
 *    matchesCallExpressio
    (node, ['Foo', 'Bar', 'Baz'])
 *
 * @param {babel.Node} expression The Babel node to match against.
 * @param {Array<string>} path The path to look for.
 */
export declare function matchesCallExpression(expression: babel.MemberExpression, path: string[]): boolean;
/**
 * Given a property or method, return its name, or undefined if that name can't
 * be determined.
 */
export declare function getPropertyName(prop: babel.ObjectProperty | babel.ObjectMethod | babel.ClassMethod | babel.SpreadProperty): string | undefined;
export declare const CLOSURE_CONSTRUCTOR_MAP: Map<string, string>;
/**
 * AST expression -> Closure type.
 *
 * Accepts literal values, and native constructors.
 *
 * @param {Node} node A Babel expression node.
 * @return {string} The type of that expression, in Closure terms.
 */
export declare function getClosureType(node: babel.Node, parsedJsdoc: doctrine.Annotation | undefined, sourceRange: SourceRange, document: ParsedDocument): Result<string, Warning>;
export declare function getAttachedComment(node: babel.Node): string | undefined;
/**
 * Returns all comments from a tree defined with @event.
 */
export declare function getEventComments(node: babel.Node): Map<string, ScannedEvent>;
export declare function getPropertyValue(node: babel.ObjectExpression, name: string): babel.Node | undefined;
/**
 * Create a ScannedMethod object from an estree Property AST node.
 */
export declare function toScannedMethod(node: babel.ObjectProperty | babel.ObjectMethod | babel.ClassMethod, sourceRange: SourceRange, document: ParsedDocument): ScannedMethod;
export declare function getReturnFromAnnotation(jsdocAnn: jsdoc.Annotation): {
    type?: string;
    desc?: string;
} | undefined;
/**
 * Examine the body of a function to see if we can infer something about its
 * return type. This currently only handles the case where a function definitely
 * returns void.
 */
export declare function inferReturnFromBody(node: babel.Function): {
    type: string;
} | undefined;
export declare function toMethodParam(nodeParam: babel.LVal, jsdocAnn?: jsdoc.Annotation): MethodParam;
export declare function getOrInferPrivacy(name: string, annotation: jsdoc.Annotation | undefined, defaultPrivacy?: Privacy): Privacy;
/**
 * Properties on element prototypes that are part of the custom elment
 * lifecycle or Polymer configuration syntax.
 *
 * TODO(rictic): only treat the Polymer ones as private when dealing with
 *   Polymer.
 */
export declare const configurationProperties: ImmutableSet<string>;
/**
 * Scan any methods on the given node, if it's a class expression/declaration.
 */
export declare function getMethods(node: babel.Node, document: JavaScriptDocument): Map<string, ScannedMethod>;
/**
 * Scan any static methods on the given node, if it's a class
 * expression/declaration.
 */
export declare function getStaticMethods(node: babel.Node, document: JavaScriptDocument): Map<string, ScannedMethod>;
export declare function extractPropertyFromGetterOrSetter(method: babel.ClassMethod | babel.ObjectMethod, jsdocAnn: jsdoc.Annotation | undefined, document: JavaScriptDocument): ScannedProperty | null;
/**
 * Extracts properties (including accessors) from a given class
 * or object expression.
 */
export declare function extractPropertiesFromClassOrObjectBody(node: babel.Class | babel.ObjectExpression, document: JavaScriptDocument): Map<string, ScannedProperty>;
