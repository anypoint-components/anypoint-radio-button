{"version":3,"sources":["javascript/javascript-parser.ts"],"names":[],"mappings":"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","file":"javascript-parser.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as babel from 'babel-types';\nimport * as babylon from 'babylon';\n\nimport {correctSourceRange, InlineDocInfo, LocationOffset, Severity, SourceRange, Warning, WarningCarryingException} from '../model/model';\nimport {ResolvedUrl} from '../model/url';\nimport {Parser} from '../parser/parser';\nimport {UrlResolver} from '../url-loader/url-resolver';\n\nimport {JavaScriptDocument} from './javascript-document';\n\nexport type SourceType = 'script'|'module';\n\ndeclare class SyntaxError {\n  message: string;\n  lineNumber: number;\n  column: number;\n}\n\nconst baseParseOptions: babylon.BabylonOptions = {\n  plugins: [\n    'asyncGenerators',\n    'dynamicImport',\n    // 'importMeta', // not yet in the @types file\n    'objectRestSpread',\n  ],\n};\n\n// TODO(usergenic): Move this to regular baseParseOptions declaration once\n// @types/babylon has been updated to include `ranges`.\n(baseParseOptions as any)['ranges'] = true;\n\nexport class JavaScriptParser implements Parser<JavaScriptDocument> {\n  readonly sourceType?: SourceType;\n\n  parse(\n      contents: string, url: ResolvedUrl, _urlResolver: UrlResolver,\n      inlineInfo?: InlineDocInfo): JavaScriptDocument {\n    const isInline = !!inlineInfo;\n    inlineInfo = inlineInfo || {};\n    const result = parseJs(\n        contents, url, inlineInfo.locationOffset, undefined, this.sourceType);\n    if (result.type === 'failure') {\n      // TODO(rictic): define and return a ParseResult instead of throwing.\n      const minimalDocument = new JavaScriptDocument({\n        url,\n        contents,\n        baseUrl: inlineInfo.baseUrl,\n        ast: null as any,\n        locationOffset: inlineInfo.locationOffset,\n        astNode: inlineInfo.astNode,\n        isInline,\n        parsedAsSourceType: 'script',\n      });\n      throw new WarningCarryingException(\n          new Warning({parsedDocument: minimalDocument, ...result.warningish}));\n    }\n\n    return new JavaScriptDocument({\n      url,\n      contents,\n      baseUrl: inlineInfo.baseUrl,\n      ast: result.parsedFile,\n      locationOffset: inlineInfo.locationOffset,\n      astNode: inlineInfo.astNode,\n      isInline,\n      parsedAsSourceType: result.sourceType,\n    });\n  }\n}\n\nexport class JavaScriptModuleParser extends JavaScriptParser {\n  readonly sourceType: SourceType = 'module';\n}\n\nexport class JavaScriptScriptParser extends JavaScriptParser {\n  readonly sourceType: SourceType = 'script';\n}\n\nexport type ParseResult = {\n  type: 'success',\n  sourceType: SourceType,\n  parsedFile: babel.File,\n}|{\n  type: 'failure',\n  warningish: {\n    sourceRange: SourceRange,\n    severity: Severity,\n    code: string,\n    message: string,\n  }\n};\n\n/**\n * Parse the given contents and return either an AST or a parse error as a\n * Warning. It needs the filename and the location offset to produce correct\n * warnings.\n */\nexport function parseJs(\n    contents: string,\n    file: ResolvedUrl,\n    locationOffset?: LocationOffset,\n    warningCode?: string,\n    sourceType?: SourceType): ParseResult {\n  if (!warningCode) {\n    warningCode = 'parse-error';\n  }\n\n  let parsedFile: babel.File;\n  const parseOptions = {sourceFilename: file, ...baseParseOptions};\n\n  try {\n    // If sourceType is not provided, we will try script first and if that\n    // fails, we will try module, since failure is probably that it can't\n    // parse the 'import' or 'export' syntax as a script.\n    if (!sourceType) {\n      try {\n        sourceType = 'script';\n        parsedFile = babylon.parse(contents, {sourceType, ...parseOptions});\n      } catch (_ignored) {\n        sourceType = 'module';\n        parsedFile = babylon.parse(contents, {sourceType, ...parseOptions});\n      }\n    } else {\n      parsedFile = babylon.parse(contents, {sourceType, ...parseOptions});\n    }\n    return {\n      type: 'success',\n      sourceType: sourceType,\n      parsedFile,\n    };\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      updateLineNumberAndColumnForError(err);\n      return {\n        type: 'failure',\n        warningish: {\n          message: err.message.split('\\n')[0],\n          severity: Severity.ERROR,\n          code: warningCode,\n          sourceRange: correctSourceRange(\n              {\n                file,\n                start: {line: err.lineNumber - 1, column: err.column - 1},\n                end: {line: err.lineNumber - 1, column: err.column - 1}\n              },\n              locationOffset)!,\n        }\n      };\n    }\n    throw err;\n  }\n}\n\n/**\n * Babylon does not provide lineNumber and column values for unexpected token\n * syntax errors.  This function parses the `(line:column)` value from the\n * message of these errors and updates the error object in place.\n */\nfunction updateLineNumberAndColumnForError(err: SyntaxError) {\n  if (typeof err.lineNumber === 'number' && typeof err.column === 'number') {\n    return;\n  }\n  if (!err.message) {\n    return;\n  }\n  const lineAndColumnMatch =\n      err.message.match(/(Unexpected token.*)\\(([0-9]+):([0-9]+)\\)/);\n  if (!lineAndColumnMatch) {\n    return;\n  }\n  err.lineNumber = parseInt(lineAndColumnMatch[2], 10);\n  err.column = parseInt(lineAndColumnMatch[3], 10) + 1;\n}\n"]}