{"version":3,"sources":["core/async-work-cache.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;;;;;;;;;AAEH,+CAAmD;AAEnD,MAAM,YAAY,GAAG,0BAAW,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC;AAEhD;;GAEG;AACH;IAEE,YAAY,IAA2B;QACrC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACT,IAAI,CAAC,eAAe,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QACvD,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,eAAe,GAAG,IAAI,GAAG,EAAE,CAAC;QACnC,CAAC;IACH,CAAC;IAED;;;;;;;;;;;;;OAaG;IACG,YAAY,CACd,GAAM,EAAE,OAAyB,EAAE,WAAW,GAAG,YAAY;;YAC/D,WAAW,CAAC,gBAAgB,EAAE,CAAC;YAC/B,OAAO,IAAI,EAAE,CAAC;gBACZ,IAAI,CAAC;oBACH,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;oBACtD,WAAW,CAAC,gBAAgB,EAAE,CAAC;oBAC/B,MAAM,CAAC,MAAM,CAAC;gBAChB,CAAC;gBAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBACb,WAAW,CAAC,gBAAgB,EAAE,CAAC;oBAC/B,EAAE,CAAC,CAAC,uBAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;wBAClB,QAAQ,CAAC;oBACX,CAAC;oBACD,MAAM,GAAG,CAAC;gBACZ,CAAC;YACH,CAAC;QACH,CAAC;KAAA;IAEa,aAAa,CAAC,GAAM,EAAE,OAAyB;;YAC3D,MAAM,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACnD,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;gBACjB,MAAM,CAAC,YAAY,CAAC;YACtB,CAAC;YACD,MAAM,OAAO,GAAG,CAAC,GAAS,EAAE;gBAC1B,wEAAwE;gBACxE,8DAA8D;gBAC9D,MAAM,OAAO,CAAC,OAAO,EAAE,CAAC;gBACxB,MAAM,CAAC,OAAO,EAAE,CAAC;YACnB,CAAC,CAAA,CAAC,EAAE,CAAC;YACL,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;YACvC,IAAI,CAAC;gBACH,MAAM,OAAO,CAAC;YAChB,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,EAAE,CAAC,CAAC,uBAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBAClB,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;gBACnC,CAAC;gBACD,MAAM,GAAG,CAAC;YACZ,CAAC;YACD,MAAM,CAAC,OAAO,CAAC;QACjB,CAAC;KAAA;IAED,MAAM,CAAC,GAAM;QACX,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACnC,CAAC;IAED,KAAK;QACH,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;IAC/B,CAAC;IAED,GAAG,CAAC,GAAM,EAAE,KAAQ;QAClB,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;IACxD,CAAC;IAED,GAAG,CAAC,GAAM;QACR,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACvC,CAAC;CACF;AAhFD,wCAgFC","file":"async-work-cache.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {CancelToken, isCancel} from 'cancel-token';\n\nconst neverCancels = CancelToken.source().token;\n\n/**\n * A map from keys to promises of values. Used for caching asynchronous work.\n */\nexport class AsyncWorkCache<K, V> {\n  private _keyToResultMap: Map<K, Promise<V>>;\n  constructor(from?: AsyncWorkCache<K, V>) {\n    if (from) {\n      this._keyToResultMap = new Map(from._keyToResultMap);\n    } else {\n      this._keyToResultMap = new Map();\n    }\n  }\n\n  /**\n   * If work has already begun to compute the given key, return a promise for\n   * the result of that work.\n   *\n   * If not, compute it with the given function.\n   *\n   * This method ensures that, in the absence of cancellations, we will only try\n   * to compute the value for `key` once, no matter how often or with what\n   * timing getOrCompute is called, even recursively.\n   *\n   * This API is safe for multiple, independently cancellable callers. So long\n   * as the given cancelToken is not cancelled, this function will not reject\n   * with a Cancel exception.\n   */\n  async getOrCompute(\n      key: K, compute: () => Promise<V>, cancelToken = neverCancels) {\n    cancelToken.throwIfRequested();\n    while (true) {\n      try {\n        const result = await this._getOrCompute(key, compute);\n        cancelToken.throwIfRequested();\n        return result;\n      } catch (err) {\n        cancelToken.throwIfRequested();\n        if (isCancel(err)) {\n          continue;\n        }\n        throw err;\n      }\n    }\n  }\n\n  private async _getOrCompute(key: K, compute: () => Promise<V>) {\n    const cachedResult = this._keyToResultMap.get(key);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    const promise = (async () => {\n      // Make sure we wait and return a Promise before doing any work, so that\n      // the Promise is cached before control flow enters compute().\n      await Promise.resolve();\n      return compute();\n    })();\n    this._keyToResultMap.set(key, promise);\n    try {\n      await promise;\n    } catch (err) {\n      if (isCancel(err)) {\n        this._keyToResultMap.delete(key);\n      }\n      throw err;\n    }\n    return promise;\n  }\n\n  delete(key: K) {\n    this._keyToResultMap.delete(key);\n  }\n\n  clear() {\n    this._keyToResultMap.clear();\n  }\n\n  set(key: K, value: V) {\n    this._keyToResultMap.set(key, Promise.resolve(value));\n  }\n\n  has(key: K) {\n    return this._keyToResultMap.has(key);\n  }\n}\n"]}