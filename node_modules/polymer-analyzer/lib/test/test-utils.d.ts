import { Analyzer } from '../core/analyzer';
import { FileRelativeUrl, PackageRelativeUrl, ParsedDocument, ResolvedUrl, ScannedFeature, UrlResolver } from '../index';
import { SourceRange, Warning } from '../model/model';
import { Scanner } from '../scanning/scanner';
import { InMemoryOverlayUrlLoader } from '../url-loader/overlay-loader';
import { UrlLoader } from '../url-loader/url-loader';
export declare class UnexpectedResolutionError extends Error {
    resolvedValue: any;
    constructor(message: string, resolvedValue: any);
}
export declare function invertPromise(promise: Promise<any>): Promise<any>;
export declare type Reference = Warning | SourceRange | undefined;
/**
 * Used for asserting that warnings or source ranges correspond to the right
 * parts of the source code.
 *
 * Non-test code probably wants WarningPrinter instead.
 */
export declare class CodeUnderliner {
    private _parsedDocumentGetter;
    constructor(urlLoader: UrlLoader, urlResolver?: UrlResolver);
    static withMapping(url: ResolvedUrl, contents: string): CodeUnderliner;
    /**
     * Converts one or more warnings/source ranges into underlined text.
     *                                                  ~~~~~~~~~~ ~~~~
     *
     * This has a loose set of types that it will accept in order to make
     * writing tests simple and legible.
     */
    underline(reference: Reference): Promise<string>;
    underline(references: ReadonlyArray<Reference>): Promise<ReadonlyArray<string>>;
}
/**
 * Run the given scanner on the given package relative url.
 *
 * The url must be loadable with the given analyzer.
 */
export declare function runScanner(analyzer: Analyzer, scanner: Scanner<ParsedDocument, any, any>, url: string): Promise<{
    features: ScannedFeature[];
    warnings: Warning[];
}>;
/**
 * Run the given scanner on some file contents as a string.
 *
 * Note that the url's file extension is relevant, because it will affect how
 * the file is parsed.
 */
export declare function runScannerOnContents(scanner: Scanner<ParsedDocument, any, any>, url: string, contents: string): Promise<{
    features: ScannedFeature[];
    warnings: Warning[];
    analyzer: Analyzer;
    urlLoader: InMemoryOverlayUrlLoader;
}>;
export declare const noOpTag: (strings: TemplateStringsArray, ...values: any[]) => string;
export declare function fileRelativeUrl(strings: TemplateStringsArray, ...values: any[]): FileRelativeUrl;
export declare function packageRelativeUrl(strings: TemplateStringsArray, ...values: any[]): PackageRelativeUrl;
export declare function resolvedUrl(strings: TemplateStringsArray, ...values: any[]): ResolvedUrl;
/**
 * On posix systems file urls look like:
 *      file:///path/to/foo
 * On windows they look like:
 *      file:///c%3A/path/to/foo
 *
 * This will produce an OS-correct file url. Pretty much only useful for testing
 * url resolvers.
 */
export declare function rootedFileUrl(strings: TemplateStringsArray, ...values: any[]): ResolvedUrl;
export declare const fixtureDir: string;
export declare function assertIsCancelled(promise: Promise<any>): Promise<void>;
