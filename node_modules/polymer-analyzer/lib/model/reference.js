"use strict";
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
const feature_1 = require("./feature");
const warning_1 = require("./warning");
/**
 * A reference to another feature by identifier.
 */
class ScannedReference extends feature_1.ScannedFeature {
    constructor(kind, identifier, sourceRange, astNode, scope, description, jsdoc, warnings) {
        super(sourceRange, astNode, description, jsdoc, warnings);
        this.kind = kind;
        this.astNode = astNode;
        this.scope = scope;
        this.sourceRange = sourceRange;
        this.identifier = identifier;
    }
    resolve(document) {
        return this.resolveWithKind(document, this.kind);
    }
    // Leaving this as a public method, in case we want to use a more
    // specific kind (e.g. resolve a PolymerElement rather than just a Class).
    resolveWithKind(document, kind) {
        const features = document.getFeatures({ imported: true, externalPackages: true, kind, id: this.identifier });
        const warnings = [...this.warnings];
        if (this.sourceRange) {
            if (features.size === 0) {
                let message = `Could not resolve reference to ${this.kind}`;
                if (kind === 'behavior') {
                    message += `. Is it annotated with @polymerBehavior?`;
                }
                warnings.push(new warning_1.Warning({
                    code: 'could-not-resolve-reference',
                    sourceRange: this.sourceRange,
                    message,
                    parsedDocument: document.parsedDocument,
                    severity: warning_1.Severity.WARNING
                }));
            }
            else if (features.size > 1) {
                warnings.push(new warning_1.Warning({
                    code: 'multiple-global-declarations',
                    sourceRange: this.sourceRange,
                    message: `Multiple global declarations of ${this.kind} with identifier ${this.identifier}`,
                    parsedDocument: document.parsedDocument,
                    severity: warning_1.Severity.WARNING
                }));
            }
        }
        let feature;
        [feature] = features;
        return new Reference(this, feature, warnings);
    }
}
exports.ScannedReference = ScannedReference;
const referenceSet = new Set(['reference']);
const emptySet = new Set();
/**
 * A reference to another feature by identifier.
 */
class Reference {
    constructor(scannedReference, feature, warnings) {
        this.kinds = referenceSet;
        this.identifiers = emptySet;
        this.identifier = scannedReference.identifier;
        this.sourceRange = scannedReference.sourceRange;
        this.warnings = warnings;
        this.feature = feature;
    }
}
exports.Reference = Reference;

//# sourceMappingURL=reference.js.map
