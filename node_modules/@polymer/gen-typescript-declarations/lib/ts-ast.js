"use strict";
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
class Document {
    constructor(data) {
        this.kind = 'document';
        this.path = data.path;
        this.members = data.members || [];
        this.referencePaths = new Set(Array.from(data.referencePaths || []));
        this.header = data.header || '';
    }
    /**
     * Iterate over all nodes in the document, depth first. Includes all
     * recursive ancestors, and the document itself.
     */
    *traverse() {
        for (const m of this.members) {
            yield* m.traverse();
        }
        yield this;
    }
    /**
     * Clean up this AST.
     */
    simplify() {
        for (const node of this.traverse()) {
            if (node.kind === 'union') {
                node.simplify();
            }
        }
    }
    serialize() {
        let out = '';
        if (this.header) {
            out += formatComment(this.header, 0) + '\n';
        }
        if (this.referencePaths.size > 0) {
            for (const ref of this.referencePaths) {
                out += `/// <reference path="${ref}" />\n`;
            }
            out += '\n';
        }
        out += this.members.map((m) => m.serialize()).join('\n');
        return out;
    }
}
exports.Document = Document;
class Namespace {
    constructor(data) {
        this.kind = 'namespace';
        this.name = data.name;
        this.description = data.description || '';
        this.members = data.members || [];
    }
    *traverse() {
        for (const m of this.members) {
            yield* m.traverse();
        }
        yield this;
    }
    serialize(depth = 0) {
        let out = '';
        if (this.description) {
            out += formatComment(this.description, depth);
        }
        const i = indent(depth);
        out += i;
        if (depth === 0) {
            out += 'declare ';
        }
        out += `namespace ${this.name} {\n`;
        for (const member of this.members) {
            out += '\n' + member.serialize(depth + 1);
        }
        out += `${i}}\n`;
        return out;
    }
}
exports.Namespace = Namespace;
class Class {
    constructor(data) {
        this.kind = 'class';
        this.name = data.name;
        this.description = data.description || '';
        this.extends = data.extends || '';
        this.mixins = data.mixins || [];
        this.properties = data.properties || [];
        this.methods = data.methods || [];
    }
    *traverse() {
        for (const p of this.properties) {
            yield* p.traverse();
        }
        for (const m of this.methods) {
            yield* m.traverse();
        }
        yield this;
    }
    serialize(depth = 0) {
        let out = '';
        const i = indent(depth);
        if (this.description) {
            out += formatComment(this.description, depth);
        }
        out += i;
        if (depth === 0) {
            out += 'declare ';
        }
        out += `class ${this.name}`;
        if (this.mixins.length) {
            const i2 = indent(depth + 1);
            out += ' extends';
            for (const mixin of this.mixins) {
                out += `\n${i2}${mixin}(`;
            }
            out += `\n${i2}${this.extends || 'Object'}`;
            out += ')'.repeat(this.mixins.length);
        }
        else if (this.extends) {
            out += ' extends ' + this.extends;
        }
        out += ' {\n';
        for (const property of this.properties) {
            out += property.serialize(depth + 1);
        }
        for (const method of this.methods) {
            out += method.serialize(depth + 1);
        }
        if (!out.endsWith('\n')) {
            out += '\n';
        }
        out += `${i}}\n`;
        return out;
    }
}
exports.Class = Class;
class Interface {
    constructor(data) {
        this.kind = 'interface';
        this.name = data.name;
        this.description = data.description || '';
        this.extends = data.extends || [];
        this.properties = data.properties || [];
        this.methods = data.methods || [];
    }
    *traverse() {
        for (const p of this.properties) {
            yield* p.traverse();
        }
        for (const m of this.methods) {
            yield* m.traverse();
        }
        yield this;
    }
    serialize(depth = 0) {
        let out = '';
        const i = indent(depth);
        if (this.description) {
            out += formatComment(this.description, depth);
        }
        out += i;
        out += `interface ${this.name}`;
        if (this.extends.length) {
            out += ' extends ' + this.extends.join(', ');
        }
        out += ' {\n';
        for (const property of this.properties) {
            out += property.serialize(depth + 1);
        }
        for (const method of this.methods) {
            out += method.serialize(depth + 1);
        }
        if (!out.endsWith('\n')) {
            out += '\n';
        }
        out += `${i}}\n`;
        return out;
    }
}
exports.Interface = Interface;
class FunctionLike {
    constructor(data) {
        this.name = data.name;
        this.description = data.description || '';
        this.params = data.params || [];
        this.returns = data.returns || exports.anyType;
        this.templateTypes = data.templateTypes || [];
        this.returnsDescription = data.returnsDescription || '';
        this.isStatic = data.isStatic || false;
    }
    serialize(depth = 0) {
        let out = '';
        const i = indent(depth);
        const annotations = [];
        for (const p of this.params) {
            if (p.description) {
                annotations.push(`@param ${p.name} ${p.description}`);
            }
        }
        if (this.returnsDescription) {
            annotations.push(`@returns ${this.returnsDescription}`);
        }
        let combinedDescription = this.description;
        if (annotations.length > 0) {
            if (combinedDescription) {
                combinedDescription += '\n\n';
            }
            combinedDescription += annotations.join('\n');
        }
        if (combinedDescription) {
            out += '\n' + formatComment(combinedDescription, depth);
        }
        out += i;
        if (depth === 0) {
            out += 'declare ';
        }
        if (this.kind === 'method' && this.isStatic) {
            out += 'static ';
        }
        if (this.kind === 'function') {
            out += 'function ';
        }
        out += this.name;
        if (this.templateTypes.length > 0) {
            out += `<${this.templateTypes.join(', ')}>`;
        }
        out += '(';
        out += this.params.map((p) => p.serialize()).join(', ');
        out += `): ${this.returns.serialize()};\n`;
        return out;
    }
}
exports.FunctionLike = FunctionLike;
class Function extends FunctionLike {
    constructor() {
        super(...arguments);
        this.kind = 'function';
    }
    *traverse() {
        for (const p of this.params) {
            yield* p.traverse();
        }
        yield* this.returns.traverse();
        yield this;
    }
}
exports.Function = Function;
class Method extends FunctionLike {
    constructor() {
        super(...arguments);
        this.kind = 'method';
    }
    *traverse() {
        for (const p of this.params) {
            yield* p.traverse();
        }
        yield* this.returns.traverse();
        yield this;
    }
}
exports.Method = Method;
class Property {
    constructor(data) {
        this.kind = 'property';
        this.name = data.name;
        this.description = data.description || '';
        this.type = data.type || exports.anyType;
        this.readOnly = data.readOnly || false;
    }
    *traverse() {
        yield* this.type.traverse();
        yield this;
    }
    serialize(depth = 0) {
        let out = '';
        const i = indent(depth);
        if (this.description) {
            out += '\n' + formatComment(this.description, depth);
        }
        out += i;
        if (this.readOnly) {
            out += 'readonly ';
        }
        out += `${quotePropertyName(this.name)}: ${this.type.serialize()};\n`;
        return out;
    }
}
exports.Property = Property;
class ConstValue {
    constructor(data) {
        this.kind = 'constValue';
        this.name = data.name;
        this.type = data.type;
    }
    *traverse() {
        yield* this.type.traverse();
        yield this;
    }
    serialize(depth = 0) {
        return `${indent(depth)}const ${this.name}: ${this.type.serialize()};\n`;
    }
}
exports.ConstValue = ConstValue;
// string, MyClass, null, undefined, any
class NameType {
    constructor(name) {
        this.kind = 'name';
        this.name = name;
    }
    ;
    *traverse() {
        yield this;
    }
    serialize() {
        return this.name;
    }
}
exports.NameType = NameType;
// foo|bar
class UnionType {
    constructor(members) {
        this.kind = 'union';
        this.members = members;
    }
    *traverse() {
        for (const m of this.members) {
            yield* m.traverse();
        }
        yield this;
    }
    /**
     * Simplify this union type:
     *
     * 1) Flatten nested unions (`foo|(bar|baz)` -> `foo|bar|baz`).
     * 2) De-duplicate identical members (`foo|bar|foo` -> `foo|bar`).
     */
    simplify() {
        const flattened = [];
        for (const m of this.members) {
            if (m.kind === 'union') {
                // Note we are not recursing here, because we assume we're being called
                // via a depth-first walk, so any union members have already been
                // simplified.
                flattened.push(...m.members);
            }
            else {
                flattened.push(m);
            }
        }
        // TODO This only de-dupes Name types. We should de-dupe Arrays and
        // Functions too.
        const deduped = [];
        const names = new Set();
        let hasNull = false;
        let hasUndefined = false;
        for (const m of flattened) {
            if (m.kind === 'name') {
                if (m.name === 'null') {
                    hasNull = true;
                }
                else if (m.name === 'undefined') {
                    hasUndefined = true;
                }
                else if (!names.has(m.name)) {
                    deduped.push(m);
                    names.add(m.name);
                }
            }
            else {
                deduped.push(m);
            }
        }
        // Always put `null` and `undefined` at the end because it's more readable.
        // Preserve declared order for everything else.
        if (hasNull) {
            deduped.push(exports.nullType);
        }
        if (hasUndefined) {
            deduped.push(exports.undefinedType);
        }
        this.members = deduped;
    }
    serialize() {
        return this.members
            .map((member) => {
            let s = member.serialize();
            if (member.kind === 'function') {
                // The function syntax is ambiguous when part of a union, so add
                // parens (e.g. `() => string|null` vs `(() => string)|null`).
                s = '(' + s + ')';
            }
            return s;
        })
            .join('|');
    }
}
exports.UnionType = UnionType;
// Array<foo>
class ArrayType {
    constructor(itemType) {
        this.kind = 'array';
        this.itemType = itemType;
    }
    *traverse() {
        yield* this.itemType.traverse();
        yield this;
    }
    serialize() {
        if (this.itemType.kind === 'name') {
            // Use the concise `foo[]` syntax when the item type is simple.
            return `${this.itemType.serialize()}[]`;
        }
        else {
            // Otherwise use the `Array<foo>` syntax which is easier to read with
            // complex types (e.g. arrays of arrays).
            return `Array<${this.itemType.serialize()}>`;
        }
    }
}
exports.ArrayType = ArrayType;
// Foo<Bar>
class ParameterizedType {
    constructor(name, itemTypes) {
        this.kind = 'parameterized';
        this.name = name;
        this.itemTypes = itemTypes;
    }
    *traverse() {
        for (const itemType of this.itemTypes) {
            yield* itemType.traverse();
        }
        yield this;
    }
    serialize() {
        const types = this.itemTypes.map((t) => t.serialize());
        return `${this.name}<${types.join(', ')}>`;
    }
}
exports.ParameterizedType = ParameterizedType;
// (foo: bar) => baz
class FunctionType {
    constructor(params, returns) {
        this.kind = 'function';
        this.params = params;
        this.returns = returns;
    }
    *traverse() {
        for (const p of this.params) {
            yield* p.traverse();
        }
        yield* this.returns.traverse();
        yield this;
    }
    serialize() {
        const params = this.params.map((param) => param.serialize());
        return `(${params.join(', ')}) => ${this.returns.serialize()}`;
    }
}
exports.FunctionType = FunctionType;
// {new(foo): bar}
class ConstructorType {
    constructor(params, returns) {
        this.kind = 'constructor';
        this.params = params;
        this.returns = returns;
    }
    *traverse() {
        for (const p of this.params) {
            yield* p.traverse();
        }
        yield* this.returns.traverse();
        yield this;
    }
    serialize() {
        const params = this.params.map((param) => param.serialize());
        return `{new(${params.join(', ')}): ${this.returns.serialize()}}`;
    }
}
exports.ConstructorType = ConstructorType;
// foo: bar
class ParamType {
    constructor(data) {
        this.kind = 'param';
        this.name = data.name;
        this.type = data.type || exports.anyType;
        this.optional = data.optional || false;
        this.rest = data.rest || false;
        this.description = data.description || '';
    }
    *traverse() {
        yield* this.type.traverse();
        yield this;
    }
    serialize() {
        let out = '';
        if (this.rest) {
            out += '...';
        }
        out += this.name;
        if (this.optional) {
            out += '?';
        }
        out += ': ' + this.type.serialize();
        return out;
    }
}
exports.ParamType = ParamType;
class RecordType {
    constructor(fields) {
        this.kind = 'record';
        this.fields = fields;
    }
    *traverse() {
        for (const f of this.fields) {
            yield* f.traverse();
        }
        yield this;
    }
    serialize() {
        const fields = this.fields.map((field) => field.serialize());
        return `{${fields.join(', ')}}`;
    }
}
exports.RecordType = RecordType;
class IntersectionType {
    constructor(types) {
        this.kind = 'intersection';
        this.types = types;
    }
    *traverse() {
        for (const t of this.types) {
            yield* t.traverse();
        }
        yield this;
    }
    serialize() {
        return this.types.map((t) => t.serialize()).join(' & ');
    }
}
exports.IntersectionType = IntersectionType;
class IndexableObjectType {
    constructor(keyType, valueType) {
        this.kind = 'indexableObject';
        this.keyType = keyType;
        this.valueType = valueType;
    }
    *traverse() {
        yield* this.keyType.traverse();
        yield* this.valueType.traverse();
        yield this;
    }
    serialize() {
        return `{[key: ${this.keyType.serialize()}]: ${this.valueType.serialize()}}`;
    }
}
exports.IndexableObjectType = IndexableObjectType;
exports.anyType = new NameType('any');
exports.nullType = new NameType('null');
exports.undefinedType = new NameType('undefined');
function quotePropertyName(name) {
    // TODO We should escape reserved words, and there are many more safe
    // characters than are included in this RegExp.
    // See https://mathiasbynens.be/notes/javascript-identifiers-es6
    const safe = name.match(/^[_$a-zA-Z][_$a-zA-Z0-9]*$/);
    return safe ? name : JSON.stringify(name);
}
const indentSpaces = 2;
function indent(depth) {
    return ' '.repeat(depth * indentSpaces);
}
function formatComment(comment, depth) {
    // Make sure we don't end our comment early by printing out the `*/` end
    // comment sequence if it is contained in the comment. Escape it as `*\/`
    // instead. One way this sequence could get here is if an HTML comment
    // embedded a JavaScript style block comment.
    comment = comment.replace(/\*\//g, '*\\/');
    // Indent the comment one space so that it doesn't touch the `*` we add next,
    // but only if there is a character there. If we also indented blank lines by
    // one space, then they would have an unneccessary space after the `*`.
    comment = comment.replace(/^(.)/gm, ' $1');
    // Indent to the given level and add the `*` character.
    const i = indent(depth);
    comment = comment.replace(/^/gm, `${i} *`);
    return `${i}/**\n${comment}\n${i} */\n`;
}
//# sourceMappingURL=ts-ast.js.map