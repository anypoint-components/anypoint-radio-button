/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
export declare type Node = Document | Declaration | Method | Type | Property;
export declare type Declaration = Namespace | Class | Interface | Function | ConstValue;
export declare class Document {
    readonly kind: string;
    path: string;
    members: Declaration[];
    referencePaths: Set<string>;
    header: string;
    constructor(data: {
        path: string;
        members?: Declaration[];
        referencePaths?: Iterable<string>;
        header?: string;
    });
    /**
     * Iterate over all nodes in the document, depth first. Includes all
     * recursive ancestors, and the document itself.
     */
    traverse(): Iterable<Node>;
    /**
     * Clean up this AST.
     */
    simplify(): void;
    serialize(): string;
}
export declare class Namespace {
    readonly kind: string;
    name: string;
    description: string;
    members: Declaration[];
    constructor(data: {
        name: string;
        description?: string;
        members?: Declaration[];
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare class Class {
    readonly kind: string;
    name: string;
    description: string;
    extends: string;
    mixins: string[];
    properties: Property[];
    methods: Method[];
    constructor(data: {
        name: string;
        description?: string;
        extends?: string;
        mixins?: string[];
        properties?: Property[];
        methods?: Method[];
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare class Interface {
    readonly kind: string;
    name: string;
    description: string;
    extends: string[];
    properties: Property[];
    methods: Method[];
    constructor(data: {
        name: string;
        description?: string;
        extends?: string[];
        properties?: Property[];
        methods?: Method[];
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare abstract class FunctionLike {
    kind: string;
    name: string;
    description: string;
    params: ParamType[];
    templateTypes: string[];
    returns: Type;
    returnsDescription: string;
    isStatic: boolean;
    constructor(data: {
        name: string;
        description?: string;
        params?: ParamType[];
        templateTypes?: string[];
        returns?: Type;
        returnsDescription?: string;
        isStatic?: boolean;
    });
    serialize(depth?: number): string;
}
export declare class Function extends FunctionLike {
    readonly kind: string;
    traverse(): Iterable<Node>;
}
export declare class Method extends FunctionLike {
    readonly kind: string;
    traverse(): Iterable<Node>;
}
export declare class Property {
    readonly kind: string;
    name: string;
    description: string;
    type: Type;
    readOnly: boolean;
    constructor(data: {
        name: string;
        description?: string;
        type?: Type;
        readOnly?: boolean;
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare class ConstValue {
    readonly kind: string;
    name: string;
    type: Type;
    constructor(data: {
        name: string;
        type: Type;
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare type Type = NameType | UnionType | ArrayType | FunctionType | ConstructorType | RecordType | IntersectionType | IndexableObjectType | ParamType | ParameterizedType;
export declare class NameType {
    readonly kind: string;
    name: string;
    constructor(name: string);
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare class UnionType {
    readonly kind: string;
    members: Type[];
    constructor(members: Type[]);
    traverse(): Iterable<Node>;
    /**
     * Simplify this union type:
     *
     * 1) Flatten nested unions (`foo|(bar|baz)` -> `foo|bar|baz`).
     * 2) De-duplicate identical members (`foo|bar|foo` -> `foo|bar`).
     */
    simplify(): void;
    serialize(): string;
}
export declare class ArrayType {
    readonly kind: string;
    itemType: Type;
    constructor(itemType: Type);
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare class ParameterizedType {
    readonly kind: string;
    itemTypes: Type[];
    name: string;
    constructor(name: string, itemTypes: Type[]);
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare class FunctionType {
    readonly kind: string;
    params: ParamType[];
    returns: Type;
    constructor(params: ParamType[], returns: Type);
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare class ConstructorType {
    readonly kind: string;
    params: ParamType[];
    returns: NameType;
    constructor(params: ParamType[], returns: NameType);
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare class ParamType {
    readonly kind: string;
    name: string;
    type: Type;
    optional: boolean;
    rest: boolean;
    description: string;
    constructor(data: {
        name: string;
        type: Type;
        optional?: boolean;
        rest?: boolean;
        description?: string;
    });
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare class RecordType {
    readonly kind: string;
    fields: ParamType[];
    constructor(fields: ParamType[]);
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare class IntersectionType {
    readonly kind: string;
    types: Type[];
    constructor(types: Type[]);
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare class IndexableObjectType {
    readonly kind: string;
    keyType: Type;
    valueType: Type;
    constructor(keyType: Type, valueType: Type);
    traverse(): Iterable<Node>;
    serialize(): string;
}
export declare const anyType: NameType;
export declare const nullType: NameType;
export declare const undefinedType: NameType;
